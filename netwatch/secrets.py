import base64
import binascii

from Crypto import Random
from Crypto.Cipher import AES
from pbkdf2 import PBKDF2

from netwatch import app


class Secrets:
    def __init__(self):
        self.salt_length = 16  # In bytes, so 16*8 = 128-bit

    def encrypt(self, pt, password=app.config['SECRET_KEY']):
        pt_utf = pt.encode()
        password_utf = password.encode()

        # Generate a random salt and use with the password to derive a key for encryption:
        key_salt = Random.new().read(self.salt_length)
        key = PBKDF2(password_utf, key_salt).read(32)  # 256-bit key for AES256

        # A random salt of the recommended length (16 byte for GCM) is used as nonce for data encryption by default:
        cipher = AES.new(key, AES.MODE_GCM)
        ct = cipher.encrypt(pt_utf)

        # Base64 encode the key salt, plus the data salt that gets generated by default, pre-fixed to the CT.
        # Then decode from UTF bytes to str. All 3 values will be stripped out later during decryption:
        return base64.b64encode(key_salt + cipher.nonce + ct).decode()

    def decrypt(self, ct_b64, password=app.config['SECRET_KEY']):
        password_utf = password.encode()

        # Try to decode the Base64 values:
        try:
            full_ct_utf = base64.b64decode(ct_b64)
        except binascii.Error:
            return "ERROR: CT looks invalid"
        except ValueError:
            return "ERROR: CT contains invalid characters"

        # Separate out the key_salt + data_salt + CT. All are already encoded as UTF
        key_salt = full_ct_utf[:self.salt_length]
        data_salt_utf = full_ct_utf[self.salt_length:(self.salt_length * 2)]
        ct_utf = full_ct_utf[(self.salt_length * 2):]

        # Check that the data is long enough after slicing to contain any CT data to decrypt:
        if len(ct_utf) == 0:
            return "ERROR: No data found"

        # Dervive the same key that was used to encrypt
        key = PBKDF2(password_utf, key_salt).read(32)

        cipher = AES.new(key, AES.MODE_GCM, nonce=data_salt_utf)
        pt_utf = cipher.decrypt(ct_utf)

        # If the decryption fails (wrong key) then the decoding will not work:
        try:
            return pt_utf.decode()
        except UnicodeDecodeError:
            return "ERROR: Unable to decrypt, check password or salt"


if __name__ == '__main__':
    secrets = Secrets()
    pt = input('Enter PT:')
    password = input('Enter password:')
    print(secrets.encrypt(pt, password))

    ct = input('Enter a B64 CT:')
    password = input('Enter password:')
    print(secrets.decrypt(ct, password))
